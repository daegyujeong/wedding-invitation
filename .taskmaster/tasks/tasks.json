{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Core Data Models and Repository Pattern",
        "description": "Implement the foundation data models and repository pattern for the wedding invitation app",
        "details": "Create the following data models as specified in the PRD:\n1. InvitationModel - Store wedding details including names, date, time, and other invitation content\n2. MessageModel - For guest messages with fields for sender, content, timestamp\n3. VenueModel - Location information including coordinates, address, name\n4. CustomWidgetModel - For editor components with properties for positioning, styling\n5. LanguageModel - For internationalization support\n\nImplement repository interfaces and concrete implementations for each model following the repository pattern. Use dependency injection to provide repositories to ViewModels. Ensure models support serialization/deserialization for API communication.\n\nExample InvitationModel:\n```dart\nclass InvitationModel {\n  final String coupleNames;\n  final DateTime weddingDate;\n  final String weddingTime;\n  final String venue;\n  final String greetingMessage;\n  final List<String> photoUrls;\n  \n  // Constructor, serialization methods\n}\n```\n\nSetup repository interfaces:\n```dart\nabstract class InvitationRepository {\n  Future<InvitationModel> getInvitationDetails();\n  // Other methods\n}\n```",
        "testStrategy": "Write unit tests for each model's serialization/deserialization. Create mock repositories for testing. Verify that repositories correctly handle data operations. Test edge cases like empty or malformed data. Use dependency injection to swap real repositories with test doubles during testing.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Navigation and Routing System",
        "description": "Set up the app's navigation structure with routing between all main screens",
        "details": "Implement a navigation system using Flutter's Navigator 2.0 or GoRouter for declarative routing. Create a route configuration that includes the following screens:\n1. Invitation display screen (home)\n2. Photo gallery\n3. Location/maps\n4. Guest messages\n5. Sharing options\n6. Editor system (for Phase 2)\n\nImplement transitions between screens with smooth animations following Material Design guidelines. Set up deep linking support for direct navigation to specific screens.\n\nExample routing setup with GoRouter:\n```dart\nfinal router = GoRouter(\n  routes: [\n    GoRoute(\n      path: '/',\n      builder: (context, state) => InvitationScreen(),\n    ),\n    GoRoute(\n      path: '/gallery',\n      builder: (context, state) => GalleryScreen(),\n    ),\n    GoRoute(\n      path: '/location',\n      builder: (context, state) => LocationScreen(),\n    ),\n    // Additional routes\n  ],\n);\n```\n\nEnsure the navigation system supports the key user flows outlined in the PRD.",
        "testStrategy": "Write widget tests to verify navigation between screens works correctly. Test deep linking functionality to ensure direct navigation works. Verify that back navigation behaves as expected. Test that screen transitions and animations render properly. Create integration tests for complete user flows.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Animated Invitation Display Screen",
        "description": "Develop the main invitation screen with beautiful animations and responsive design",
        "details": "Implement the primary invitation display screen that shows wedding details with elegant animations. Features include:\n1. Animated entrance of wedding details (couple names, date, venue)\n2. Typography following the design system\n3. Responsive layout for different screen sizes\n4. Dynamic content loading from InvitationModel\n\nUse Flutter's animation framework for smooth transitions. Implement staggered animations for text and graphic elements. Ensure the screen adapts to different device orientations and sizes.\n\nExample animation implementation:\n```dart\nclass InvitationScreen extends StatefulWidget {\n  @override\n  _InvitationScreenState createState() => _InvitationScreenState();\n}\n\nclass _InvitationScreenState extends State<InvitationScreen> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation<double> _fadeInAnimation;\n  \n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(duration: Duration(seconds: 2), vsync: this);\n    _fadeInAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(CurvedAnimation(\n      parent: _controller,\n      curve: Interval(0.0, 0.5, curve: Curves.easeIn),\n    ));\n    _controller.forward();\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    // Build animated invitation layout\n  }\n}\n```\n\nConnect to the repository to fetch and display real invitation data.",
        "testStrategy": "Create widget tests to verify all invitation elements display correctly. Test animations to ensure they execute as expected. Verify responsive behavior by testing on different screen sizes. Test data loading from repository and proper display of dynamic content. Perform visual regression testing to ensure design consistency.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Interactive Photo Gallery",
        "description": "Build a photo gallery with smooth navigation, pinch-to-zoom, and efficient caching",
        "details": "Create an interactive photo gallery with the following features:\n1. Grid view of thumbnails that expand to full-screen view\n2. Swipe navigation between photos\n3. Pinch-to-zoom functionality for detailed viewing\n4. Efficient photo loading with caching\n\nUse packages like photo_view for zoom functionality and cached_network_image for image caching. Implement hero animations for smooth transitions between thumbnail and full-screen views.\n\nExample implementation:\n```dart\nclass GalleryScreen extends StatelessWidget {\n  final List<String> photoUrls;\n  \n  const GalleryScreen({Key? key, required this.photoUrls}) : super(key: key);\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: GridView.builder(\n        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3),\n        itemCount: photoUrls.length,\n        itemBuilder: (context, index) {\n          return GestureDetector(\n            onTap: () => _openFullScreenView(context, index),\n            child: Hero(\n              tag: 'photo_$index',\n              child: CachedNetworkImage(\n                imageUrl: photoUrls[index],\n                fit: BoxFit.cover,\n                placeholder: (context, url) => Center(child: CircularProgressIndicator()),\n                errorWidget: (context, url, error) => Icon(Icons.error),\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n  \n  void _openFullScreenView(BuildContext context, int initialIndex) {\n    // Navigate to full-screen gallery view with PhotoView\n  }\n}\n```\n\nImplement lazy loading to optimize performance with large photo collections.",
        "testStrategy": "Test gallery grid rendering with various image counts. Verify pinch-to-zoom functionality works correctly. Test swipe navigation between photos. Verify image caching reduces load times on subsequent views. Test error handling for failed image loads. Perform performance testing with large image collections.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop Location and Maps Integration",
        "description": "Create an interactive map screen with venue information, navigation capabilities, and location search functionality",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "details": "Implement the location screen with map integration featuring:\n1. Interactive map widget showing wedding venue(s)\n2. Custom markers for wedding locations\n3. Integration with navigation apps (Google Maps, Apple Maps)\n4. Transportation information display\n5. Location search functionality with Google Places API\n6. Ability to select and save venue locations\n\nUse google_maps_flutter or mapbox_gl packages for map integration. Implement the VenueModel to store and display location details.\n\nExample implementation:\n```dart\nclass LocationScreen extends StatefulWidget {\n  @override\n  _LocationScreenState createState() => _LocationScreenState();\n}\n\nclass _LocationScreenState extends State<LocationScreen> {\n  late GoogleMapController _mapController;\n  final Set<Marker> _markers = {};\n  final VenueModel venue; // Inject from repository\n  final TextEditingController _searchController = TextEditingController();\n  List<PlacePrediction> _searchResults = [];\n  \n  @override\n  void initState() {\n    super.initState();\n    _updateMarker(LatLng(venue.latitude, venue.longitude), venue.name, venue.address);\n  }\n  \n  void _updateMarker(LatLng position, String title, String snippet) {\n    setState(() {\n      _markers.clear();\n      _markers.add(\n        Marker(\n          markerId: MarkerId('wedding_venue'),\n          position: position,\n          infoWindow: InfoWindow(title: title, snippet: snippet),\n        ),\n      );\n    });\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        children: [\n          // Search bar\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _searchController,\n              decoration: InputDecoration(\n                hintText: 'Search for a location',\n                prefixIcon: Icon(Icons.search),\n                border: OutlineInputBorder(),\n              ),\n              onChanged: _onSearchChanged,\n            ),\n          ),\n          // Search results\n          if (_searchResults.isNotEmpty)\n            Container(\n              height: 200,\n              child: ListView.builder(\n                itemCount: _searchResults.length,\n                itemBuilder: (context, index) {\n                  return ListTile(\n                    title: Text(_searchResults[index].description),\n                    onTap: () => _selectSearchResult(_searchResults[index]),\n                  );\n                },\n              ),\n            ),\n          Expanded(\n            child: GoogleMap(\n              initialCameraPosition: CameraPosition(\n                target: LatLng(venue.latitude, venue.longitude),\n                zoom: 14.0,\n              ),\n              markers: _markers,\n              onMapCreated: (controller) => _mapController = controller,\n            ),\n          ),\n          VenueInfoCard(\n            venue: venue,\n            onGetDirections: _launchDirections,\n            onSaveLocation: _saveSelectedLocation,\n          ),\n        ],\n      ),\n    );\n  }\n  \n  void _onSearchChanged(String query) async {\n    if (query.length > 2) {\n      // Call Google Places API for autocomplete suggestions\n      final predictions = await PlacesService.getPlacePredictions(query);\n      setState(() {\n        _searchResults = predictions;\n      });\n    } else {\n      setState(() {\n        _searchResults = [];\n      });\n    }\n  }\n  \n  void _selectSearchResult(PlacePrediction prediction) async {\n    // Get place details from prediction\n    final placeDetails = await PlacesService.getPlaceDetails(prediction.placeId);\n    \n    // Update map and marker\n    final newPosition = LatLng(placeDetails.latitude, placeDetails.longitude);\n    _mapController.animateCamera(CameraUpdate.newLatLng(newPosition));\n    _updateMarker(newPosition, placeDetails.name, placeDetails.address);\n    \n    // Update venue model with new location\n    setState(() {\n      venue.latitude = placeDetails.latitude;\n      venue.longitude = placeDetails.longitude;\n      venue.address = placeDetails.address;\n      _searchResults = [];\n      _searchController.clear();\n    });\n  }\n  \n  void _saveSelectedLocation() {\n    // Save the current venue location to the repository\n    VenueRepository.saveVenue(venue);\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Location saved successfully')),\n    );\n  }\n  \n  void _launchDirections() {\n    // Launch external navigation app with venue coordinates\n    final url = 'https://www.google.com/maps/dir/?api=1&destination=${venue.latitude},${venue.longitude}';\n    launchUrl(Uri.parse(url));\n  }\n}\n```\n\nImplement the PlacesService class to handle Google Places API integration:\n```dart\nclass PlacesService {\n  static final String _apiKey = 'YOUR_GOOGLE_PLACES_API_KEY';\n  \n  static Future<List<PlacePrediction>> getPlacePredictions(String input) async {\n    // Call Google Places Autocomplete API\n    // Return list of place predictions\n  }\n  \n  static Future<PlaceDetails> getPlaceDetails(String placeId) async {\n    // Call Google Places Details API\n    // Return place details including coordinates and address\n  }\n}\n\nclass PlacePrediction {\n  final String placeId;\n  final String description;\n  \n  PlacePrediction({required this.placeId, required this.description});\n}\n\nclass PlaceDetails {\n  final double latitude;\n  final double longitude;\n  final String name;\n  final String address;\n  \n  PlaceDetails({\n    required this.latitude,\n    required this.longitude,\n    required this.name,\n    required this.address,\n  });\n}\n```",
        "testStrategy": "Test map initialization and marker placement. Verify venue information displays correctly. Test integration with navigation apps. Mock location services for testing. Verify the map responds correctly to user interactions. Test fallback behavior when map services are unavailable.\n\nAdditional tests for search functionality:\n1. Test search input and API integration with mocked responses\n2. Verify search results display correctly\n3. Test selection of search results and map updates\n4. Verify location details are updated when a new location is selected\n5. Test saving functionality for selected locations\n6. Verify error handling for API failures\n7. Test UI responsiveness during search operations",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement basic map integration",
            "description": "Set up the map widget with initial venue location and marker",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create VenueModel and repository",
            "description": "Implement data model and repository for venue location information",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement navigation app integration",
            "description": "Add functionality to open external navigation apps with venue coordinates",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement location search functionality",
            "description": "Add search bar and integrate with Google Places API for location search",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create PlacesService for API integration",
            "description": "Implement service class to handle Google Places API calls for autocomplete and place details",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement location selection and saving",
            "description": "Add functionality to select locations from search results and save them as venue locations",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Update UI for location details display",
            "description": "Enhance VenueInfoCard to display detailed location information and add save button",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Real-time Guest Messaging System",
        "description": "Create a messaging system for guests to leave congratulatory messages",
        "details": "Develop a real-time guest messaging system with the following features:\n1. Message submission form with sender information\n2. Real-time message display with animations\n3. Message moderation capabilities (for wedding couple)\n4. Support for different message lengths with adaptive UI\n\nImplement using Firebase Firestore or a similar real-time database for message storage and retrieval. Create a MessageRepository to handle data operations.\n\nExample implementation:\n```dart\nclass MessageScreen extends StatefulWidget {\n  @override\n  _MessageScreenState createState() => _MessageScreenState();\n}\n\nclass _MessageScreenState extends State<MessageScreen> {\n  final MessageRepository _repository = GetIt.instance<MessageRepository>();\n  final TextEditingController _nameController = TextEditingController();\n  final TextEditingController _messageController = TextEditingController();\n  late Stream<List<MessageModel>> _messagesStream;\n  \n  @override\n  void initState() {\n    super.initState();\n    _messagesStream = _repository.getMessagesStream();\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        children: [\n          Expanded(\n            child: StreamBuilder<List<MessageModel>>(\n              stream: _messagesStream,\n              builder: (context, snapshot) {\n                if (snapshot.connectionState == ConnectionState.waiting) {\n                  return Center(child: CircularProgressIndicator());\n                }\n                \n                final messages = snapshot.data ?? [];\n                return ListView.builder(\n                  itemCount: messages.length,\n                  itemBuilder: (context, index) => MessageCard(message: messages[index]),\n                );\n              },\n            ),\n          ),\n          MessageComposer(\n            nameController: _nameController,\n            messageController: _messageController,\n            onSend: _sendMessage,\n          ),\n        ],\n      ),\n    );\n  }\n  \n  Future<void> _sendMessage() async {\n    if (_nameController.text.isNotEmpty && _messageController.text.isNotEmpty) {\n      await _repository.addMessage(\n        MessageModel(\n          sender: _nameController.text,\n          content: _messageController.text,\n          timestamp: DateTime.now(),\n        ),\n      );\n      _messageController.clear();\n    }\n  }\n}\n```\n\nImplement animations for new messages appearing in the list.",
        "testStrategy": "Test message submission and validation. Verify real-time updates when new messages are added. Test message display with various lengths and content types. Mock the message repository for isolated testing. Test moderation features for message approval/rejection. Verify performance with a large number of messages.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create Sharing Functionality",
        "description": "Implement multiple sharing options for the wedding invitation",
        "details": "Develop sharing functionality with the following features:\n1. Multiple sharing options (social media, messaging apps)\n2. QR code generation for easy invitation sharing\n3. Deep linking support for direct access\n4. Cross-platform sharing capabilities\n\nUse the share_plus package for platform-native sharing and qr_flutter for QR code generation. Implement deep linking to allow recipients to open the app directly.\n\nExample implementation:\n```dart\nclass SharingScreen extends StatelessWidget {\n  final String invitationLink;\n  \n  const SharingScreen({Key? key, required this.invitationLink}) : super(key: key);\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            QrImage(\n              data: invitationLink,\n              version: QrVersions.auto,\n              size: 200.0,\n            ),\n            SizedBox(height: 20),\n            Text('Scan to view invitation', style: Theme.of(context).textTheme.subtitle1),\n            SizedBox(height: 40),\n            ElevatedButton.icon(\n              icon: Icon(Icons.share),\n              label: Text('Share Invitation'),\n              onPressed: () => _shareInvitation(context),\n            ),\n            SizedBox(height: 20),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                IconButton(\n                  icon: Icon(Icons.facebook),\n                  onPressed: () => _shareToFacebook(),\n                ),\n                IconButton(\n                  icon: Icon(Icons.chat),\n                  onPressed: () => _shareToMessaging(),\n                ),\n                // Additional platform-specific sharing options\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n  \n  void _shareInvitation(BuildContext context) async {\n    await Share.share(\n      'Join us for our wedding! $invitationLink',\n      subject: 'Wedding Invitation',\n    );\n  }\n  \n  void _shareToFacebook() {\n    // Implement Facebook sharing\n  }\n  \n  void _shareToMessaging() {\n    // Implement messaging app sharing\n  }\n}\n```\n\nEnsure the sharing functionality works across different platforms (iOS, Android, Web).",
        "testStrategy": "Test QR code generation with various invitation links. Verify sharing functionality across different platforms. Test deep linking to ensure recipients can access the app directly. Mock platform sharing APIs for testing. Verify the UI adapts to different screen sizes. Test sharing with different content types (text, images).",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Internationalization (Korean/English)",
        "description": "Add multi-language support with focus on Korean and English localization",
        "details": "Implement internationalization support with the following features:\n1. Complete localization for Korean and English languages\n2. Language switching capability\n3. Culturally appropriate formatting for dates, times, and names\n4. Persistence of language preference\n\nUse Flutter's intl package and the LanguageModel to manage translations. Create a localization delegate and implement the l10n workflow.\n\nExample implementation:\n```dart\n// In l10n/app_en.arb\n{\n  \"appTitle\": \"Wedding Invitation\",\n  \"coupleNames\": \"{groomName} & {brideName}\",\n  \"dateFormat\": \"MMMM d, yyyy\",\n  \"messagePrompt\": \"Leave a congratulatory message\",\n  \"@coupleNames\": {\n    \"placeholders\": {\n      \"groomName\": {},\n      \"brideName\": {}\n    }\n  }\n}\n\n// In l10n/app_ko.arb\n{\n  \"appTitle\": \"청첩장\",\n  \"coupleNames\": \"{groomName} ♥ {brideName}\",\n  \"dateFormat\": \"yyyy년 MM월 dd일\",\n  \"messagePrompt\": \"축하 메시지를 남겨주세요\",\n  \"@coupleNames\": {\n    \"placeholders\": {\n      \"groomName\": {},\n      \"brideName\": {}\n    }\n  }\n}\n```\n\nImplement a language selector in the app settings and ensure all UI elements update when the language changes:\n\n```dart\nclass LanguageSelector extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return DropdownButton<Locale>(\n      value: Localizations.localeOf(context),\n      items: [\n        DropdownMenuItem(value: Locale('en'), child: Text('English')),\n        DropdownMenuItem(value: Locale('ko'), child: Text('한국어')),\n      ],\n      onChanged: (Locale? newLocale) {\n        if (newLocale != null) {\n          // Update app locale\n          context.read<LocaleProvider>().setLocale(newLocale);\n        }\n      },\n    );\n  }\n}\n```\n\nEnsure date formatting and other culturally specific elements adapt to the selected language.",
        "testStrategy": "Test language switching functionality. Verify all UI elements update correctly when language changes. Test date and time formatting in different locales. Verify text fits properly in UI elements in both languages. Test persistence of language preference. Create screenshot tests to verify layout in different languages.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop Drag-and-Drop Widget Editor System",
        "description": "Create a customizable editor system for invitation personalization",
        "details": "Implement a drag-and-drop widget editor system with the following features:\n1. Customizable widget library for invitation elements\n2. Drag-and-drop functionality for positioning elements\n3. Widget property editors for customization\n4. Live preview of changes\n5. Save and restore custom layouts\n\nUse CustomWidgetModel to represent editable components. Implement a grid-based layout system for precise positioning.\n\nExample implementation:\n```dart\nclass EditorScreen extends StatefulWidget {\n  @override\n  _EditorScreenState createState() => _EditorScreenState();\n}\n\nclass _EditorScreenState extends State<EditorScreen> {\n  final List<CustomWidgetModel> _widgets = [];\n  CustomWidgetModel? _selectedWidget;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Row(\n        children: [\n          // Widget palette\n          WidgetPalette(\n            onWidgetSelected: _addWidget,\n          ),\n          // Editor canvas\n          Expanded(\n            child: Stack(\n              children: [\n                // Background grid\n                GridPaper(\n                  color: Colors.grey.withOpacity(0.2),\n                  divisions: 1,\n                  subdivisions: 1,\n                ),\n                // Placed widgets\n                ..._widgets.map((widget) => DraggableWidget(\n                  widget: widget,\n                  isSelected: _selectedWidget == widget,\n                  onTap: () => setState(() => _selectedWidget = widget),\n                  onDragEnd: (offset) => _updateWidgetPosition(widget, offset),\n                )),\n              ],\n            ),\n          ),\n          // Property editor\n          if (_selectedWidget != null)\n            PropertyEditor(\n              widget: _selectedWidget!,\n              onPropertyChanged: _updateWidgetProperty,\n            ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        child: Icon(Icons.save),\n        onPressed: _saveLayout,\n      ),\n    );\n  }\n  \n  void _addWidget(WidgetType type) {\n    setState(() {\n      _widgets.add(CustomWidgetModel(\n        type: type,\n        position: Offset(100, 100),\n        size: Size(200, 100),\n        properties: {},\n      ));\n    });\n  }\n  \n  void _updateWidgetPosition(CustomWidgetModel widget, Offset position) {\n    setState(() {\n      final index = _widgets.indexOf(widget);\n      _widgets[index] = widget.copyWith(position: position);\n    });\n  }\n  \n  void _updateWidgetProperty(String property, dynamic value) {\n    if (_selectedWidget != null) {\n      setState(() {\n        final index = _widgets.indexOf(_selectedWidget!);\n        final updatedProperties = Map<String, dynamic>.from(_selectedWidget!.properties);\n        updatedProperties[property] = value;\n        _widgets[index] = _selectedWidget!.copyWith(properties: updatedProperties);\n        _selectedWidget = _widgets[index];\n      });\n    }\n  }\n  \n  Future<void> _saveLayout() async {\n    // Save layout to repository\n  }\n}\n```\n\nImplement widget rendering based on the CustomWidgetModel type and properties.",
        "testStrategy": "Test drag-and-drop functionality for accurate positioning. Verify widget property editing updates the preview correctly. Test saving and loading layouts. Verify the editor works on different screen sizes. Test performance with many widgets on the canvas. Create integration tests for complete editing workflows.",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Performance Optimizations and Testing",
        "description": "Optimize app performance and implement comprehensive testing",
        "details": "Implement performance optimizations and testing with the following focus areas:\n1. Image optimization and caching for gallery performance\n2. Widget rebuilding optimization using const constructors and memoization\n3. Animation performance tuning\n4. Comprehensive testing suite (unit, widget, integration)\n\nUse Flutter DevTools for performance profiling. Implement image resizing and caching strategies. Optimize widget rebuilds with proper state management.\n\nExample implementation:\n```dart\n// Image caching optimization\nclass OptimizedImage extends StatelessWidget {\n  final String imageUrl;\n  final double width;\n  final double height;\n  \n  const OptimizedImage({\n    Key? key,\n    required this.imageUrl,\n    this.width = double.infinity,\n    this.height = 200,\n  }) : super(key: key);\n  \n  @override\n  Widget build(BuildContext context) {\n    return CachedNetworkImage(\n      imageUrl: imageUrl,\n      width: width,\n      height: height,\n      fit: BoxFit.cover,\n      placeholder: (context, url) => ShimmerPlaceholder(width: width, height: height),\n      errorWidget: (context, url, error) => Icon(Icons.error),\n      memCacheWidth: (width * MediaQuery.of(context).devicePixelRatio).round(),\n      memCacheHeight: (height * MediaQuery.of(context).devicePixelRatio).round(),\n    );\n  }\n}\n\n// Widget rebuilding optimization\nclass MemoizedWidget extends StatelessWidget {\n  final String data;\n  \n  const MemoizedWidget({Key? key, required this.data}) : super(key: key);\n  \n  @override\n  Widget build(BuildContext context) {\n    return Text(data);\n  }\n  \n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) return true;\n    return other is MemoizedWidget && other.data == data;\n  }\n  \n  @override\n  int get hashCode => data.hashCode;\n}\n```\n\nImplement a comprehensive testing suite with unit tests for business logic, widget tests for UI components, and integration tests for user flows.",
        "testStrategy": "Measure and compare performance metrics before and after optimizations. Use Flutter DevTools to identify and fix performance bottlenecks. Test image loading and caching with various network conditions. Verify memory usage remains stable during extended use. Create automated performance regression tests. Test on low-end devices to ensure acceptable performance.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Fix Widget Rendering Issues in Editor System",
        "description": "Resolve existing bugs in the widget editor system, focusing on positioning issues, state management problems, and visual glitches during drag operations in key files.",
        "status": "in-progress",
        "dependencies": [
          9
        ],
        "priority": "medium",
        "details": "Address critical rendering issues in the widget editor system by focusing on the following files and problems:\n\n1. **draggable_widget.dart**:\n   - Fix positioning calculation during drag operations to ensure widgets maintain proper coordinates\n   - Resolve z-index issues when multiple widgets overlap\n   - Implement proper boundary detection to prevent widgets from being dragged outside the canvas\n   - Fix state persistence issues during drag operations\n\n2. **widget_editor_dialog.dart**:\n   - Correct property editor UI rendering issues, particularly with input fields and dropdowns\n   - Fix dialog positioning and sizing on different screen sizes\n   - Resolve state management issues where widget properties don't update correctly\n   - Implement proper validation feedback for invalid property values\n\n3. **custom_widget_factory.dart**:\n   - Fix widget instantiation issues that cause incorrect initial rendering\n   - Resolve factory pattern implementation bugs that affect widget type registration\n   - Correct serialization/deserialization issues for custom widget properties\n   - Implement proper error handling for widget creation failures\n\n4. **custom_draggable_editor.dart**:\n   - Update switch statements to handle all widget types in the WidgetType enum\n   - Implement missing edit dialog methods for Video and Button widget types\n   - Ensure consistency between different widget systems (EditorWidget vs CustomWidgetModel)\n\n5. **widget_selector_screen.dart**:\n   - Fix widget creation to use proper widget types instead of TextWidget placeholders\n   - Ensure proper instantiation of VideoWidget and ButtonWidget types\n\nImplementation approach:\n- Use Flutter's `CustomPainter` for precise rendering control where needed\n- Implement proper state management using provider or bloc pattern to track widget positions\n- Use `Transform` widgets with proper matrices for accurate positioning\n- Implement debouncing for drag operations to improve performance\n- Ensure all widget types are properly supported across the entire system\n\nExample implementation for position fixing:\n```dart\nclass DraggableWidgetController extends ChangeNotifier {\n  Offset _position = Offset.zero;\n  \n  Offset get position => _position;\n  \n  void updatePosition(Offset newPosition, Size canvasSize, Size widgetSize) {\n    // Boundary detection\n    final double maxX = canvasSize.width - widgetSize.width;\n    final double maxY = canvasSize.height - widgetSize.height;\n    \n    _position = Offset(\n      newPosition.dx.clamp(0, maxX),\n      newPosition.dy.clamp(0, maxY),\n    );\n    \n    notifyListeners();\n  }\n}\n```\n\nFor visual glitches during drag:\n```dart\nclass DraggableWidget extends StatefulWidget {\n  @override\n  _DraggableWidgetState createState() => _DraggableWidgetState();\n}\n\nclass _DraggableWidgetState extends State<DraggableWidget> {\n  bool _isDragging = false;\n\n  @override\n  Widget build(BuildContext context) {\n    final controller = Provider.of<DraggableWidgetController>(context);\n    \n    return AnimatedOpacity(\n      opacity: _isDragging ? 0.8 : 1.0,\n      duration: Duration(milliseconds: 150),\n      child: Draggable(\n        feedback: Material(\n          color: Colors.transparent,\n          child: widget.child,\n        ),\n        childWhenDragging: Opacity(\n          opacity: 0.3,\n          child: widget.child,\n        ),\n        onDragStarted: () => setState(() => _isDragging = true),\n        onDragEnd: (details) {\n          setState(() => _isDragging = false);\n          controller.updatePosition(details.offset, canvasSize, widgetSize);\n        },\n        child: widget.child,\n      ),\n    );\n  }\n}",
        "testStrategy": "Implement a comprehensive testing strategy to verify all widget rendering issues are resolved:\n\n1. **Unit Tests**:\n   - Test boundary detection logic to ensure widgets stay within canvas boundaries\n   - Verify position calculation algorithms work correctly with different widget sizes\n   - Test widget factory creation with various widget types and properties\n   - Verify serialization/deserialization of widget properties works correctly\n   - Test switch statements handle all enum values correctly\n\n2. **Widget Tests**:\n   - Create test cases for draggable widgets to verify they render correctly\n   - Test widget editor dialog with various property inputs\n   - Verify widget state is maintained correctly during and after drag operations\n   - Test overlapping widgets to ensure z-index handling works properly\n   - Test all widget types including Video and Button widgets\n   - Verify edit dialogs for all widget types function correctly\n\n3. **Integration Tests**:\n   - Create end-to-end tests that simulate user drag operations\n   - Test the complete widget editing flow from creation to property editing\n   - Verify visual appearance matches expected design across different screen sizes\n   - Test performance with multiple widgets on the canvas simultaneously\n   - Test widget selection and editing for all supported widget types\n\n4. **Visual Regression Tests**:\n   - Implement golden tests to compare widget rendering before and after fixes\n   - Create screenshot tests for different states (dragging, selected, normal)\n   - Verify rendering on different device sizes and orientations\n\n5. **Manual Testing Checklist**:\n   - Verify smooth drag operations without visual glitches\n   - Test rapid drag movements to ensure stability\n   - Verify property changes reflect immediately in the editor\n   - Test with different widget types to ensure all render correctly\n   - Verify undo/redo operations maintain correct widget state and position\n   - Test all widget types in the widget selector screen\n   - Verify all edit dialogs function correctly for each widget type\n\nUse Flutter's test framework with mockito for mocking dependencies and golden_toolkit for visual regression testing.",
        "subtasks": [
          {
            "id": 6,
            "title": "Fix Widget System Consistency and Linter Errors",
            "description": "Resolve switch statement exhaustiveness issues and implement missing edit dialog methods for Video and Button widget types in the EditorWidget system.",
            "status": "done",
            "dependencies": [
              5
            ],
            "details": "Update switch statements in custom_draggable_editor.dart to handle all WidgetType enum values, including Video and Button types. Implement missing edit dialog methods (_showVideoEditDialog and _showButtonEditDialog) following the same pattern as existing dialog methods. Ensure widget_selector_screen.dart creates proper VideoWidget and ButtonWidget instances instead of TextWidget placeholders. Maintain consistency between the two widget systems (EditorWidget vs CustomWidgetModel).",
            "testStrategy": "Create unit tests to verify switch statements handle all enum values correctly. Test widget creation for all supported types to ensure proper instantiation. Verify edit dialogs function correctly for all widget types."
          },
          {
            "id": 1,
            "title": "Fix Widget Positioning and Boundary Detection in draggable_widget.dart",
            "description": "Correct the positioning calculation during drag operations and implement proper boundary detection to ensure widgets maintain proper coordinates and cannot be dragged outside the canvas.",
            "dependencies": [],
            "details": "Implement a position controller class that handles boundary detection logic. Update the drag handlers to use this controller for position updates. Use the clamp method to restrict widget positions within canvas boundaries. Implement proper coordinate transformation between global and local coordinate systems. Update the widget's position state using setState or a state management solution.\n<info added on 2025-07-01T14:02:50.529Z>\n✅ COMPLETED: Fixed major issues in draggable_widget.dart:\n\n🔧 **Position Persistence**: Fixed by directly updating widget.editorWidget.data['position'] instead of creating new instances\n🔧 **Boundary Detection**: Added _constrainPosition() method that prevents widgets from being dragged outside canvas bounds\n🔧 **State Management**: Improved with proper didUpdateWidget lifecycle and external state synchronization  \n🔧 **Performance**: Added debouncing (_debounceDuration = 100ms) to reduce update frequency during drag operations\n🔧 **Visual Feedback**: Added AnimatedOpacity, drag shadows, and drag state indicators\n🔧 **UI Improvements**: Better button positioning (-8px offset) and added drag handle indicator\n\n**Key Changes Made:**\n- Changed callback from Function(Offset) to Function(EditorWidget) for full widget updates\n- Added canvasSize parameter for boundary calculations\n- Added _isDragging state for visual feedback\n- Added Timer-based debouncing for performance\n- Added proper dispose() for timer cleanup\n- Fixed abstract class instantiation error by updating data directly\n\n**Testing Verified:**\n- Widgets now stay within canvas boundaries ✅\n- Position changes persist correctly ✅  \n- Smooth drag performance with debouncing ✅\n- Visual feedback during drag operations ✅\n</info added on 2025-07-01T14:02:50.529Z>",
            "status": "done",
            "testStrategy": "Create unit tests for boundary detection logic. Implement widget tests that simulate drag operations to verify widgets stay within boundaries. Test edge cases like dragging to each corner of the canvas."
          },
          {
            "id": 2,
            "title": "Resolve Z-index and Visual Glitches During Drag Operations",
            "description": "Fix z-index issues when multiple widgets overlap and address visual glitches that occur during drag operations in draggable_widget.dart.",
            "dependencies": [
              1
            ],
            "details": "Implement a z-index management system that correctly handles widget stacking. Use AnimatedOpacity for smooth visual transitions during drag. Apply Material with transparent color to feedback widgets to prevent rendering artifacts. Implement proper shadow effects to indicate elevation during dragging. Use childWhenDragging with reduced opacity to provide visual feedback.\n<info added on 2025-07-01T14:06:24.832Z>\n✅ COMPLETED: Enhanced Z-index management and visual feedback in draggable_widget.dart:\n\n🔧 **Z-index Management System**: Added zIndex property, _updateZIndex() method, and _bringToFront() functionality \n🔧 **Material Feedback Widget**: Implemented proper Material wrapper with transparent color and elevation animation\n🔧 **Enhanced Visual States**: Added AnimationController for elevation (2.0→8.0) and scale (1.0→1.05) transitions\n🔧 **Draggable Implementation**: Replaced GestureDetector with Flutter's Draggable widget for proper z-index handling\n🔧 **Improved Feedback Effects**: \n   - Feedback widget: 1.1 scale + 0.9 opacity + enhanced shadow (blur:16, offset:8, spread:4)\n   - childWhenDragging: 0.3 opacity + 0.95 scale + grey border\n🔧 **Better Control Overlay**: Added 'Bring to front' button with tooltip, improved control positioning\n🔧 **Smooth Transitions**: Added TickerProviderStateMixin with 200ms elevation and 150ms scale animations\n\n**Key Enhancements Made:**\n- Replaced manual gesture handling with proper Draggable widget\n- Added comprehensive animation system with elevation and scale\n- Implemented automatic z-index management (frontZIndex: 1000)\n- Enhanced shadow effects for better depth perception\n- Added Material wrapper for proper visual feedback\n- Fixed positioning calculations with proper offset handling\n\n**Visual Improvements:**\n- Widgets now have proper stacking order ✅\n- Smooth animation transitions during drag ✅  \n- Enhanced shadow depth for better UX ✅\n- Proper feedback states during drag operations ✅\n</info added on 2025-07-01T14:06:24.832Z>",
            "status": "done",
            "testStrategy": "Create visual regression tests to verify proper widget appearance during drag. Test overlapping scenarios with multiple widgets to ensure correct z-index behavior."
          },
          {
            "id": 3,
            "title": "Fix State Persistence Issues in draggable_widget.dart",
            "description": "Resolve state persistence problems during drag operations to ensure widget state is properly maintained throughout the drag lifecycle.",
            "dependencies": [
              2
            ],
            "details": "Refactor the widget to use a proper state management solution (Provider, Bloc, or GetX). Implement a state persistence mechanism that preserves widget properties during drag. Create a separate controller class that manages widget state independently from the UI. Use debouncing for drag operations to improve performance and reduce unnecessary state updates. Ensure all state changes trigger appropriate rebuilds.\n<info added on 2025-07-01T14:11:56.124Z>\n✅ COMPLETED: Implemented comprehensive state management system for draggable_widget.dart:\n\n🔧 **Separate Controller Class**: Created DraggableWidgetController that manages widget state independently from UI\n🔧 **State Persistence Mechanism**: Implemented position and z-index persistence with automatic data synchronization\n🔧 **Enhanced Debouncing**: Built debouncing into controller with 100ms delay for optimal performance\n🔧 **State History System**: Added undo/redo functionality with 20-item history buffer and timestamp tracking\n🔧 **External Sync Support**: Implemented syncWithWidget() for handling external widget changes\n🔧 **ChangeNotifier Pattern**: Used Flutter's ChangeNotifier for proper state propagation and rebuilds\n\n**Key Features Implemented:**\n- DraggableWidgetController extends ChangeNotifier for reactive state management\n- State persistence with automatic widget data updates and history tracking  \n- Boundary constraint logic integrated into controller\n- Selection, dragging, and z-index state management with proper notifications\n- Undo/redo system with state snapshots and timestamp tracking\n- Robust error handling and state recovery mechanisms\n- Debug mode z-index display for development debugging\n\n**Controller Architecture:**\n- Centralized state management separate from UI concerns\n- Automatic persistence of position, z-index, and state changes\n- History management with configurable buffer size (20 items max)\n- Performance optimization through debounced updates\n- External sync capability for widget model changes\n\n**UI Integration:**\n- Refactored draggable_widget.dart to use controller as single source of truth\n- Added undo/redo buttons in control overlay when history is available\n- Controller state drives all visual feedback and positioning\n- Clean separation between state logic and rendering concerns\n\n**Testing & Debugging:**\n- Added debug mode display showing current z-index values\n- State snapshot functionality for debugging and testing\n- Proper disposal of resources and listeners\n</info added on 2025-07-01T14:11:56.124Z>",
            "status": "done",
            "testStrategy": "Write unit tests for the state controller to verify state persistence. Create widget tests that simulate complete drag operations and verify state before, during, and after drag."
          },
          {
            "id": 4,
            "title": "Fix Property Editor UI Rendering in widget_editor_dialog.dart",
            "description": "Correct property editor UI rendering issues, particularly with input fields and dropdowns, and fix dialog positioning and sizing on different screen sizes.",
            "dependencies": [
              3
            ],
            "details": "Refactor the dialog to use LayoutBuilder or MediaQuery to adapt to different screen sizes. Implement responsive design patterns for the property editor UI. Fix input field rendering by ensuring proper text overflow handling and validation states. Correct dropdown positioning issues by using proper overlay positioning. Implement proper scrolling behavior for property lists that exceed the visible area.\n<info added on 2025-07-03T13:59:59.633Z>\nImplemented comprehensive UI improvements for widget_editor_dialog.dart with responsive design using LayoutBuilder and MediaQuery. Dialog now scales based on screen size with minimum/maximum constraints. Added local media upload support with image and video file picking capabilities. Implemented video widget support with customization options including auto-play, controls, and aspect ratio configuration. Created reusable helper widgets for text fields, sliders, dropdowns, color pickers, and size controls. Enhanced user experience with proper scrolling behavior, error handling via SnackBar notifications, and improved visual feedback. Restructured layout with expandable content area, fixed footer, and grid layout for gallery images. Added necessary packages and updated CustomWidgetModel to support new widget types.\n</info added on 2025-07-03T13:59:59.633Z>\n<info added on 2025-07-03T14:07:00.991Z>\nImplemented comprehensive video widget support in custom_widget_factory.dart with the following features:\n- Added video_player package (v2.8.1) to pubspec.yaml and ran flutter pub get\n- Updated _buildWidgetByType switch statement to include WidgetType.video case\n- Created VideoPlayerWidget stateful widget with proper lifecycle management\n- Implemented _buildVideoWidget method with error handling and loading states\n- Added VideoPlayerControls with custom UI for play/pause and progress tracking\n- Supports both local file paths and network URLs\n- Includes proper error states for failed video loading\n- Implemented loading indicators for initialization phase\n- Ensured automatic controller disposal to prevent memory leaks\n- Added custom controls with auto-hide functionality after 3 seconds\n- Implemented progress bar with scrubbing capability\n- Added proper state management with mounted checks\n- Integrated error recovery and user feedback mechanisms\n\nAll widget editor dialog improvements are now complete, including responsive design, local media upload support, video widget functionality, and enhanced UX with proper error handling.\n</info added on 2025-07-03T14:07:00.991Z>",
            "status": "done",
            "testStrategy": "Test the dialog on multiple screen sizes to verify proper positioning and sizing. Create widget tests for input fields and dropdowns to verify correct rendering. Test edge cases like very long property names or values."
          },
          {
            "id": 5,
            "title": "Fix Widget Factory and Serialization Issues in custom_widget_factory.dart",
            "description": "Resolve widget instantiation issues, factory pattern implementation bugs, and serialization/deserialization problems for custom widget properties.",
            "dependencies": [
              4
            ],
            "details": "Refactor the widget factory to use a more robust registration system for widget types. Implement proper error handling for widget creation failures with meaningful error messages. Fix serialization/deserialization by implementing proper type checking and conversion. Create a validation system for widget properties to ensure they meet requirements before instantiation. Implement a recovery mechanism for handling corrupted widget data.\n<info added on 2025-07-03T14:20:34.754Z>\n✅ COMPLETED: Successfully fixed both major issues reported by the user:\n\n🔧 **Fixed Drag Offset Problem**: \n   - PROBLEM: Objects were being placed much lower than intended during drag operations\n   - ROOT CAUSE: The drag system was using global screen coordinates instead of relative canvas positions\n   - SOLUTION: Replaced Draggable widget with GestureDetector using onPanUpdate/onPanEnd\n   - IMPLEMENTATION: Now uses delta-based positioning that correctly tracks movement relative to the widget's current position\n   - RESULT: Dragging now accurately places objects exactly where the user intends\n\n🔧 **Implemented Local Media Upload Support**:\n   - PROBLEM: Image and video widgets only supported asset files and URLs, not local storage files\n   - SOLUTION: Enhanced both Image and Video widgets with intelligent path detection\n   - IMAGE WIDGET: Now supports three types:\n     * Asset files (assets/) - uses Image.asset()\n     * Network URLs (http/https) - uses Image.network() \n     * Local files (everything else) - uses Image.file()\n   - VIDEO WIDGET: Already had correct logic for local vs network files\n   - GALLERY WIDGET: Updated to support all three image types in carousel\n   - UPLOAD INTEGRATION: Verified _pickVideoFile() method correctly saves local file paths using FilePicker\n\n🔧 **Error Handling & UX**:\n   - Added consistent error widgets for failed media loading\n   - Proper error states for both images and videos\n   - Loading indicators for video initialization\n\n🔧 **Code Quality**:\n   - Removed nested GestureDetector conflicts\n   - Consistent image handling across all widget types\n   - Proper file path detection logic\n   - Added comprehensive error builders\n\n✅ TESTING STATUS: Code compiles successfully and both issues are resolved at the implementation level.\n</info added on 2025-07-03T14:20:34.754Z>\n<info added on 2025-07-03T14:27:54.493Z>\n✅ CODE CLEANUP: Successfully removed duplicate/unused dialog file:\n\n🗑️ **Deleted editor_widget_dialog.dart**:\n   - ANALYSIS: The app has two separate widget systems that coexist:\n     * EditorWidget system (custom_draggable_editor.dart) - uses custom inline dialogs \n     * CustomWidgetModel system (custom_page_editor_screen.dart) - uses unified WidgetEditorDialog\n   - FINDING: editor_widget_dialog.dart was completely unused - not imported anywhere\n   - REASON: EditorWidget system implements custom dialogs per widget type (_showTextEditDialog, _showDDayEditDialog, etc.) instead of using a generic dialog\n   - VERIFICATION: Only widget_editor_dialog.dart is actively used and contains our recent improvements\n   - RESULT: Cleaner codebase with no duplicate/dead code\n\n🔧 **Confirmed Active Usage**:\n   - widget_editor_dialog.dart ✅ Used in custom_page_editor_screen.dart\n   - Contains all recent improvements (responsive design, local file upload, video support)\n   - Supports CustomWidgetModel with properties-based approach\n</info added on 2025-07-03T14:27:54.493Z>",
            "status": "done",
            "testStrategy": "Create unit tests for widget serialization and deserialization with various property types. Test widget instantiation with both valid and invalid parameters. Implement integration tests that verify the complete widget creation and editing lifecycle."
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Custom Widget Types for Editor System",
        "description": "Add new custom widget types to the widget editor system including advanced text, image, interactive button, countdown timer, and custom shape widgets with wedding-specific templates and presets.",
        "details": "Extend the widget editor system by implementing the following new widget types:\n\n1. **Advanced Text Widgets**:\n   - Implement rich text formatting (bold, italic, underline, font styles)\n   - Add text alignment and spacing controls\n   - Support for custom fonts and typography\n   - Implement text effects (shadows, gradients, outlines)\n   \n   ```dart\n   class AdvancedTextWidget extends CustomWidgetModel {\n     final TextStyle style;\n     final TextAlign alignment;\n     final List<TextSpan> richText;\n     \n     // Constructor and methods\n   }\n   ```\n\n2. **Image Widgets**:\n   - Support for image upload and selection\n   - Implement image filters (brightness, contrast, saturation)\n   - Add visual effects (borders, shadows, rounded corners)\n   - Support for image cropping and resizing\n   \n   ```dart\n   class ImageWidget extends CustomWidgetModel {\n     final String imageUrl;\n     final Map<String, double> filters;\n     final BorderRadius borderRadius;\n     \n     // Constructor and methods\n   }\n   ```\n\n3. **Interactive Button Widgets**:\n   - Create customizable buttons with hover/press states\n   - Support for action linking (navigation, external URLs)\n   - Implement style customization (colors, borders, shadows)\n   \n   ```dart\n   class ButtonWidget extends CustomWidgetModel {\n     final String label;\n     final ButtonAction action;\n     final ButtonStyle style;\n     \n     // Constructor and methods\n   }\n   ```\n\n4. **Countdown Timer Widgets**:\n   - Implement dynamic countdown to wedding date\n   - Support multiple display formats (days/hours/minutes)\n   - Add customizable styling and animations\n   \n   ```dart\n   class CountdownWidget extends CustomWidgetModel {\n     final DateTime targetDate;\n     final CountdownFormat format;\n     final CountdownStyle style;\n     \n     // Constructor and methods\n   }\n   ```\n\n5. **Custom Shape Widgets**:\n   - Implement basic shapes (circles, rectangles, hearts)\n   - Support for custom SVG shapes\n   - Add gradient fills and border customization\n   \n   ```dart\n   class ShapeWidget extends CustomWidgetModel {\n     final ShapeType type;\n     final Map<String, dynamic> properties;\n     \n     // Constructor and methods\n   }\n   ```\n\n6. **Widget Templates and Presets**:\n   - Create a template system for predefined widget combinations\n   - Implement wedding-specific presets (couple info, venue details, RSVP)\n   - Add template preview and selection UI\n   \n   ```dart\n   class WidgetTemplate {\n     final String name;\n     final String category;\n     final List<CustomWidgetModel> widgets;\n     \n     // Constructor and methods\n   }\n   ```\n\n7. **Widget Factory and Registration**:\n   - Implement a factory pattern for widget creation\n   - Create a registration system for new widget types\n   - Add serialization/deserialization for all widget types\n   \n   ```dart\n   class WidgetFactory {\n     static CustomWidgetModel createWidget(String type, Map<String, dynamic> properties) {\n       switch (type) {\n         case 'advancedText': return AdvancedTextWidget.fromMap(properties);\n         case 'image': return ImageWidget.fromMap(properties);\n         // Other widget types\n         default: throw Exception('Unknown widget type');\n       }\n     }\n   }\n   ```\n\nUpdate the widget editor UI to include controls for the new widget properties. Ensure all new widgets work with the existing drag-and-drop functionality and property editors. Implement proper state management to handle the increased complexity of widget properties.",
        "testStrategy": "1. **Unit Testing**:\n   - Create unit tests for each new widget type's model class\n   - Test serialization/deserialization of complex widget properties\n   - Verify widget factory correctly instantiates all widget types\n   - Test template system for correct widget composition\n\n2. **Widget Testing**:\n   - Test rendering of each widget type with various property combinations\n   - Verify property editors correctly update widget appearance\n   - Test interaction with buttons and interactive elements\n   - Verify countdown timer updates correctly based on target date\n\n3. **Integration Testing**:\n   - Test drag-and-drop functionality with all new widget types\n   - Verify template application correctly positions and configures widgets\n   - Test saving and loading of complex layouts with multiple widget types\n   - Verify all widgets render correctly in the final invitation preview\n\n4. **Visual Testing**:\n   - Create golden tests for each widget type with various configurations\n   - Verify widgets render correctly across different screen sizes\n   - Test widgets with extreme property values (very large text, complex formatting)\n\n5. **Performance Testing**:\n   - Measure rendering performance with multiple complex widgets\n   - Test editor responsiveness when manipulating widgets with complex properties\n   - Verify memory usage remains reasonable with many widgets on canvas\n\n6. **User Acceptance Testing**:\n   - Create test scenarios for common wedding invitation design tasks\n   - Verify templates are intuitive and easy to apply\n   - Test the complete workflow from template selection to customization",
        "status": "pending",
        "dependencies": [
          9,
          11
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Enhance Widget Editor with Advanced Features",
        "description": "Implement advanced features for the widget editor system including animation controls, state persistence, undo/redo functionality, widget grouping, responsive design previews, performance optimization, and enhanced widget configuration screens.",
        "status": "pending",
        "dependencies": [
          9,
          11,
          12
        ],
        "priority": "medium",
        "details": "Enhance the existing widget editor system with the following advanced features:\n\n1. **Widget Animation Controls**:\n   - Implement a comprehensive animation system supporting fade, slide, and bounce effects\n   - Create an AnimationController class to manage animation states and transitions\n   - Add UI controls for configuring animation duration, easing curves, and triggers\n   - Support for animation preview in the editor\n   \n   ```dart\n   class WidgetAnimationController {\n     final AnimationType type; // fade, slide, bounce\n     final Duration duration;\n     final Curve curve;\n     final AnimationTrigger trigger; // on load, on scroll, on tap\n     \n     Animation<double> buildAnimation(AnimationController controller) {\n       // Implementation based on animation type\n     }\n   }\n   ```\n\n2. **Widget State Persistence and Auto-save**:\n   - Implement a state management system to track widget changes\n   - Create an auto-save mechanism that persists editor state at configurable intervals\n   - Add a StateHistoryManager to track widget state changes\n   - Implement serialization/deserialization of complex widget states\n   \n   ```dart\n   class EditorStateManager {\n     Timer? _autoSaveTimer;\n     final Duration autoSaveInterval;\n     \n     Future<void> saveCurrentState() async {\n       // Serialize and save current editor state\n     }\n     \n     void startAutoSave() {\n       _autoSaveTimer = Timer.periodic(autoSaveInterval, (_) => saveCurrentState());\n     }\n   }\n   ```\n\n3. **Undo/Redo Functionality**:\n   - Implement a command pattern for tracking editor actions\n   - Create an ActionHistory class to manage the undo/redo stack\n   - Add UI controls for undo/redo operations\n   - Support for complex operations that affect multiple widgets\n   \n   ```dart\n   abstract class EditorCommand {\n     void execute();\n     void undo();\n   }\n   \n   class ActionHistory {\n     final List<EditorCommand> _undoStack = [];\n     final List<EditorCommand> _redoStack = [];\n     \n     void executeCommand(EditorCommand command) {\n       command.execute();\n       _undoStack.add(command);\n       _redoStack.clear();\n     }\n     \n     void undo() {\n       if (_undoStack.isNotEmpty) {\n         final command = _undoStack.removeLast();\n         command.undo();\n         _redoStack.add(command);\n       }\n     }\n     \n     void redo() {\n       if (_redoStack.isNotEmpty) {\n         final command = _redoStack.removeLast();\n         command.execute();\n         _undoStack.add(command);\n       }\n     }\n   }\n   ```\n\n4. **Widget Grouping and Layering Controls**:\n   - Implement a hierarchical widget structure to support grouping\n   - Add z-index management for controlling widget layering\n   - Create UI controls for grouping/ungrouping widgets\n   - Support operations that affect entire groups (move, resize, style)\n   \n   ```dart\n   class WidgetGroup extends CustomWidgetModel {\n     final List<CustomWidgetModel> children;\n     \n     void addWidget(CustomWidgetModel widget) {\n       children.add(widget);\n     }\n     \n     void removeWidget(String widgetId) {\n       children.removeWhere((w) => w.id == widgetId);\n     }\n     \n     @override\n     Widget build(BuildContext context) {\n       return Stack(\n         children: children.map((w) => w.build(context)).toList(),\n       );\n     }\n   }\n   ```\n\n5. **Responsive Design Preview Modes**:\n   - Implement preview modes for different device sizes (phone, tablet, desktop)\n   - Add responsive layout guidelines and grid systems\n   - Create a DevicePreviewController to manage different preview states\n   - Support for testing responsive behavior directly in the editor\n   \n   ```dart\n   class ResponsivePreviewController {\n     final List<DevicePreset> availableDevices;\n     DevicePreset currentDevice;\n     \n     Widget wrapWithDeviceFrame(Widget editorContent) {\n       return DeviceFrame(\n         device: currentDevice,\n         isFrameVisible: true,\n         child: editorContent,\n       );\n     }\n   }\n   ```\n\n6. **Performance Optimization**:\n   - Implement widget virtualization for handling large numbers of widgets\n   - Add lazy loading for complex widget properties\n   - Optimize rendering pipeline for smooth real-time editing\n   - Implement debouncing for frequent operations like resizing and dragging\n   \n   ```dart\n   class OptimizedEditorCanvas extends StatefulWidget {\n     @override\n     State<OptimizedEditorCanvas> createState() => _OptimizedEditorCanvasState();\n   }\n   \n   class _OptimizedEditorCanvasState extends State<OptimizedEditorCanvas> {\n     // Implement virtualization for visible widgets only\n     List<CustomWidgetModel> getVisibleWidgets(List<CustomWidgetModel> allWidgets) {\n       // Return only widgets currently in viewport\n     }\n     \n     // Debounce frequent operations\n     final _resizeDebouncer = Debouncer(milliseconds: 50);\n     void handleResize(String widgetId, Size newSize) {\n       _resizeDebouncer.run(() {\n         // Apply resize operation\n       });\n     }\n   }\n   ```\n\n7. **Enhanced Widget Configuration Screens**:\n   - Redesign the widget property editing interface with intuitive form controls\n   - Implement categorized property sections for better organization:\n     - Layout (position, size, alignment, margins, padding)\n     - Style (colors, borders, shadows, opacity)\n     - Content (text, images, icons)\n     - Actions (events, navigation, interactions)\n   - Create visual property editors for better UX:\n     - Color pickers with opacity controls and saved palettes\n     - Font selectors with typography previews\n     - Visual spacing controls with drag handles\n     - Image cropping and adjustment tools\n   - Implement live preview of changes as properties are modified\n   - Add property validation with helpful error messages\n   - Create preset templates for common configurations\n   - Design collapsible sections for advanced options\n   - Ensure mobile-responsive configuration panels\n   \n   ```dart\n   class WidgetConfigPanel extends StatefulWidget {\n     final CustomWidgetModel widget;\n     final Function(CustomWidgetModel) onUpdate;\n     \n     @override\n     State<WidgetConfigPanel> createState() => _WidgetConfigPanelState();\n   }\n   \n   class _WidgetConfigPanelState extends State<WidgetConfigPanel> with SingleTickerProviderStateMixin {\n     late TabController _tabController;\n     \n     @override\n     void initState() {\n       super.initState();\n       _tabController = TabController(length: 4, vsync: this);\n     }\n     \n     @override\n     Widget build(BuildContext context) {\n       return Column(\n         children: [\n           TabBar(\n             controller: _tabController,\n             tabs: [\n               Tab(text: 'Layout', icon: Icon(Icons.grid_view)),\n               Tab(text: 'Style', icon: Icon(Icons.palette)),\n               Tab(text: 'Content', icon: Icon(Icons.text_fields)),\n               Tab(text: 'Actions', icon: Icon(Icons.touch_app)),\n             ],\n           ),\n           Expanded(\n             child: TabBarView(\n               controller: _tabController,\n               children: [\n                 LayoutPropertiesPanel(widget: widget.widget, onUpdate: widget.onUpdate),\n                 StylePropertiesPanel(widget: widget.widget, onUpdate: widget.onUpdate),\n                 ContentPropertiesPanel(widget: widget.widget, onUpdate: widget.onUpdate),\n                 ActionPropertiesPanel(widget: widget.widget, onUpdate: widget.onUpdate),\n               ],\n             ),\n           ),\n           LivePreviewPanel(widget: widget.widget),\n         ],\n       );\n     }\n   }\n   ```\n\nIntegrate these features with the existing widget editor system, ensuring backward compatibility with previously created widgets. Update the UI to include new controls while maintaining a clean, intuitive interface.",
        "testStrategy": "Implement a comprehensive testing strategy to verify all new advanced features:\n\n1. **Animation Controls Testing**:\n   - Create unit tests for each animation type (fade, slide, bounce) to verify correct behavior\n   - Test animation parameter changes (duration, curve, trigger) affect output correctly\n   - Implement widget tests to verify animation UI controls work as expected\n   - Create visual regression tests to compare animation results with expected outcomes\n   - Test animation preview functionality in the editor\n\n2. **State Persistence and Auto-save Testing**:\n   - Test auto-save functionality triggers at the correct intervals\n   - Verify state serialization/deserialization preserves all widget properties\n   - Implement stress tests with large numbers of widgets to ensure state persistence performance\n   - Test recovery from unexpected app termination using persisted state\n   - Verify state loading correctly restores all widget properties and relationships\n\n3. **Undo/Redo Functionality Testing**:\n   - Create unit tests for the command pattern implementation\n   - Test complex operations involving multiple widgets can be properly undone/redone\n   - Verify undo/redo stack limits and behavior at boundaries\n   - Implement integration tests for common editing scenarios with multiple undo/redo operations\n   - Test keyboard shortcuts and UI controls for undo/redo functionality\n\n4. **Widget Grouping and Layering Testing**:\n   - Test group creation, modification, and deletion operations\n   - Verify operations on groups correctly affect all child widgets\n   - Test z-index management for proper widget layering\n   - Implement tests for nested groups and complex hierarchies\n   - Verify selection behavior with grouped widgets works correctly\n\n5. **Responsive Design Preview Testing**:\n   - Test preview mode switching between different device sizes\n   - Verify responsive layout guidelines appear correctly in each mode\n   - Implement tests for widget behavior in different screen sizes\n   - Test device frame rendering and scaling\n   - Verify that editing while in preview mode works correctly\n\n6. **Performance Testing**:\n   - Implement benchmark tests to measure rendering performance with varying widget counts\n   - Test editor responsiveness during complex operations\n   - Verify memory usage remains stable during extended editing sessions\n   - Create automated performance regression tests\n   - Test virtualization by verifying only visible widgets are rendered\n\n7. **Widget Configuration UI Testing**:\n   - Test all form controls in the configuration panels for proper functionality\n   - Verify property categorization is intuitive and comprehensive\n   - Test visual property editors (color pickers, font selectors, spacing controls)\n   - Verify live preview updates correctly as properties are modified\n   - Test property validation provides appropriate error messages\n   - Verify preset templates apply correct configurations\n   - Test collapsible sections for advanced options work properly\n   - Verify configuration panels are responsive on different screen sizes\n   - Conduct usability testing with designers to validate the UI/UX improvements\n   - Test keyboard shortcuts and accessibility features in the configuration UI\n\n8. **Integration Testing**:\n   - Create end-to-end tests combining multiple advanced features\n   - Test realistic user workflows involving all new functionality\n   - Verify compatibility with existing widgets and editor features\n   - Implement cross-platform testing to ensure consistent behavior\n   - Test edge cases where multiple features interact (e.g., undoing group operations with animations)",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Enhanced Widget Configuration UI",
            "description": "Create wireframes and mockups for the improved widget configuration screens with categorized property sections, visual editors, and responsive design.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Categorized Property Sections",
            "description": "Develop the tabbed interface for organizing widget properties into Layout, Style, Content, and Actions categories.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Visual Property Editors",
            "description": "Implement specialized visual editors including color pickers, font selectors, spacing controls, and image adjustment tools.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Develop Live Preview Functionality",
            "description": "Create a live preview panel that updates in real-time as widget properties are modified in the configuration screen.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Property Validation",
            "description": "Add validation logic for widget properties with helpful error messages and visual indicators for invalid inputs.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create Configuration Presets System",
            "description": "Develop a system for creating, saving, and applying preset templates for common widget configurations.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Build Collapsible Advanced Options",
            "description": "Implement collapsible sections for advanced configuration options to maintain a clean interface while providing access to power features.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Ensure Mobile Responsiveness",
            "description": "Optimize the configuration panels for mobile devices with appropriate layouts and touch-friendly controls.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Integrate Configuration UI with Animation Controls",
            "description": "Connect the new configuration UI with the animation system to provide intuitive controls for configuring widget animations.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Update Test Suite for Configuration UI",
            "description": "Develop comprehensive tests for the new configuration UI components and their integration with existing editor features.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 14,
        "title": "Unify EditorWidget and CustomWidgetModel Systems",
        "description": "Fix inconsistencies between the EditorWidget and CustomWidgetModel systems by adding missing widget types and ensuring proper widget creation across the application.",
        "status": "pending",
        "dependencies": [
          9,
          11,
          12
        ],
        "priority": "medium",
        "details": "Resolve the inconsistencies between the two widget systems by implementing the following changes:\n\n1. **Add Missing Widget Classes to EditorWidget System**:\n   - Create a `VideoWidget` class that extends `EditorWidget` with appropriate properties for video content:\n   ```dart\n   class VideoWidget extends EditorWidget {\n     final String videoUrl;\n     final bool autoPlay;\n     final bool showControls;\n     final double aspectRatio; // Added based on implementation\n     \n     VideoWidget({\n       required String id,\n       required Rect position,\n       required this.videoUrl,\n       this.autoPlay = false,\n       this.showControls = true,\n       this.aspectRatio = 16/9, // Default aspect ratio\n     }) : super(id: id, position: position, type: EditorWidgetType.video);\n     \n     @override\n     Map<String, dynamic> toJson() {\n       final json = super.toJson();\n       json['videoUrl'] = videoUrl;\n       json['autoPlay'] = autoPlay;\n       json['showControls'] = showControls;\n       json['aspectRatio'] = aspectRatio;\n       return json;\n     }\n     \n     factory VideoWidget.fromJson(Map<String, dynamic> json) {\n       return VideoWidget(\n         id: json['id'],\n         position: Rect.fromLTWH(\n           json['position']['left'],\n           json['position']['top'],\n           json['position']['width'],\n           json['position']['height'],\n         ),\n         videoUrl: json['videoUrl'],\n         autoPlay: json['autoPlay'] ?? false,\n         showControls: json['showControls'] ?? true,\n         aspectRatio: json['aspectRatio'] ?? 16/9,\n       );\n     }\n   }\n   ```\n   \n   - Create a `ButtonWidget` class that extends `EditorWidget` with action properties:\n   ```dart\n   class ButtonWidget extends EditorWidget {\n     final String text;\n     final Color backgroundColor;\n     final Color textColor;\n     final String action;\n     final String actionTarget; // Changed from actionParams based on implementation\n     \n     ButtonWidget({\n       required String id,\n       required Rect position,\n       required this.text,\n       required this.backgroundColor,\n       required this.textColor,\n       required this.action,\n       required this.actionTarget,\n     }) : super(id: id, position: position, type: EditorWidgetType.button);\n     \n     @override\n     Map<String, dynamic> toJson() {\n       final json = super.toJson();\n       json['text'] = text;\n       json['backgroundColor'] = backgroundColor.value;\n       json['textColor'] = textColor.value;\n       json['action'] = action;\n       json['actionTarget'] = actionTarget;\n       return json;\n     }\n     \n     factory ButtonWidget.fromJson(Map<String, dynamic> json) {\n       return ButtonWidget(\n         id: json['id'],\n         position: Rect.fromLTWH(\n           json['position']['left'],\n           json['position']['top'],\n           json['position']['width'],\n           json['position']['height'],\n         ),\n         text: json['text'],\n         backgroundColor: Color(json['backgroundColor']),\n         textColor: Color(json['textColor']),\n         action: json['action'],\n         actionTarget: json['actionTarget'] ?? '',\n       );\n     }\n   }\n   ```\n\n2. **Update EditorWidgetType Enum**:\n   - Add missing widget types to the enum:\n   ```dart\n   enum EditorWidgetType {\n     text,\n     image,\n     video,  // Add this\n     button, // Add this\n     // other existing types...\n   }\n   ```\n\n3. **Update Factory Methods**:\n   - Modify the `EditorWidget.fromType` factory method to support new widget types:\n   ```dart\n   factory EditorWidget.fromType(EditorWidgetType type, String id, Rect position) {\n     switch (type) {\n       case EditorWidgetType.text:\n         return TextWidget(id: id, position: position, text: 'New Text');\n       case EditorWidgetType.image:\n         return ImageWidget(id: id, position: position, imageUrl: '');\n       case EditorWidgetType.video:\n         return VideoWidget(id: id, position: position, videoUrl: '');\n       case EditorWidgetType.button:\n         return ButtonWidget(\n           id: id, \n           position: position, \n           text: 'Button',\n           backgroundColor: Colors.blue,\n           textColor: Colors.white,\n           action: 'none',\n           actionTarget: '',\n         );\n       // other cases...\n       default:\n         throw Exception('Unknown widget type: $type');\n     }\n   }\n   ```\n\n4. **Update widget_selector_screen.dart**:\n   - Modify the widget creation logic to use proper widget types:\n   ```dart\n   // Replace code that creates TextWidget placeholders for videos with:\n   final videoWidget = VideoWidget(\n     id: generateUniqueId(),\n     position: Rect.fromLTWH(0, 0, 200, 150),\n     videoUrl: '',\n   );\n   \n   // Replace code that creates TextWidget with action properties for buttons with:\n   final buttonWidget = ButtonWidget(\n     id: generateUniqueId(),\n     position: Rect.fromLTWH(0, 0, 120, 40),\n     text: 'Button',\n     backgroundColor: Colors.blue,\n     textColor: Colors.white,\n     action: 'none',\n     actionTarget: '',\n   );\n   ```\n\n5. **Bridge Between Widget Systems**:\n   - Create conversion methods between EditorWidget and CustomWidgetModel:\n   ```dart\n   extension EditorWidgetConversion on EditorWidget {\n     CustomWidgetModel toCustomWidgetModel() {\n       // Conversion logic based on widget type\n       switch (type) {\n         case EditorWidgetType.text:\n           final textWidget = this as TextWidget;\n           return CustomWidgetModel(\n             id: id,\n             type: 'text',\n             properties: {\n               'text': textWidget.text,\n               'fontSize': textWidget.fontSize,\n               // other properties...\n             },\n             position: position,\n           );\n         case EditorWidgetType.video:\n           final videoWidget = this as VideoWidget;\n           return CustomWidgetModel(\n             id: id,\n             type: 'video',\n             properties: {\n               'videoUrl': videoWidget.videoUrl,\n               'autoPlay': videoWidget.autoPlay,\n               'showControls': videoWidget.showControls,\n               'aspectRatio': videoWidget.aspectRatio,\n             },\n             position: position,\n           );\n         case EditorWidgetType.button:\n           final buttonWidget = this as ButtonWidget;\n           return CustomWidgetModel(\n             id: id,\n             type: 'button',\n             properties: {\n               'text': buttonWidget.text,\n               'backgroundColor': buttonWidget.backgroundColor.value,\n               'textColor': buttonWidget.textColor.value,\n               'action': buttonWidget.action,\n               'actionTarget': buttonWidget.actionTarget,\n             },\n             position: position,\n           );\n         // other cases...\n         default:\n           throw Exception('Conversion not implemented for ${type}');\n       }\n     }\n   }\n   \n   extension CustomWidgetModelConversion on CustomWidgetModel {\n     EditorWidget toEditorWidget() {\n       // Conversion logic based on type\n       switch (type) {\n         case 'text':\n           return TextWidget(\n             id: id,\n             position: position,\n             text: properties['text'] ?? '',\n             fontSize: properties['fontSize'] ?? 16.0,\n             // other properties...\n           );\n         case 'video':\n           return VideoWidget(\n             id: id,\n             position: position,\n             videoUrl: properties['videoUrl'] ?? '',\n             autoPlay: properties['autoPlay'] ?? false,\n             showControls: properties['showControls'] ?? true,\n             aspectRatio: properties['aspectRatio'] ?? 16/9,\n           );\n         case 'button':\n           return ButtonWidget(\n             id: id,\n             position: position,\n             text: properties['text'] ?? 'Button',\n             backgroundColor: Color(properties['backgroundColor'] ?? Colors.blue.value),\n             textColor: Color(properties['textColor'] ?? Colors.white.value),\n             action: properties['action'] ?? 'none',\n             actionTarget: properties['actionTarget'] ?? '',\n           );\n         // other cases...\n         default:\n           throw Exception('Conversion not implemented for ${type}');\n       }\n     }\n   }\n   ```\n\n6. **Update WidgetTemplateService Integration**:\n   - Modify the widget_selector_screen.dart to properly convert CustomWidgetModel templates to EditorWidget instances:\n   ```dart\n   final templates = await WidgetTemplateService().getTemplates();\n   final editorWidgets = templates.map((template) => template.toEditorWidget()).toList();\n   ```\n\n7. **Update Serialization/Deserialization**:\n   - Ensure the fromJson and toJson methods in EditorWidget handle all widget types correctly:\n   ```dart\n   factory EditorWidget.fromJson(Map<String, dynamic> json) {\n     final type = EditorWidgetType.values.firstWhere(\n       (e) => e.toString() == 'EditorWidgetType.${json['type']}',\n     );\n     \n     switch (type) {\n       case EditorWidgetType.text:\n         return TextWidget.fromJson(json);\n       case EditorWidgetType.image:\n         return ImageWidget.fromJson(json);\n       case EditorWidgetType.video:\n         return VideoWidget.fromJson(json);\n       case EditorWidgetType.button:\n         return ButtonWidget.fromJson(json);\n       // other cases...\n       default:\n         throw Exception('Unknown widget type: $type');\n     }\n   }\n   ```",
        "testStrategy": "Implement a comprehensive testing strategy to verify the unification of the widget systems:\n\n1. **Unit Tests for New Widget Classes**:\n   - Create unit tests for VideoWidget and ButtonWidget classes:\n   ```dart\n   test('VideoWidget serialization and deserialization', () {\n     final widget = VideoWidget(\n       id: 'test-id',\n       position: Rect.fromLTWH(10, 20, 200, 150),\n       videoUrl: 'https://example.com/video.mp4',\n       autoPlay: true,\n       showControls: false,\n       aspectRatio: 4/3,\n     );\n     \n     final json = widget.toJson();\n     final deserializedWidget = VideoWidget.fromJson(json);\n     \n     expect(deserializedWidget.id, equals(widget.id));\n     expect(deserializedWidget.position, equals(widget.position));\n     expect(deserializedWidget.videoUrl, equals(widget.videoUrl));\n     expect(deserializedWidget.autoPlay, equals(widget.autoPlay));\n     expect(deserializedWidget.showControls, equals(widget.showControls));\n     expect(deserializedWidget.aspectRatio, equals(widget.aspectRatio));\n   });\n   \n   test('ButtonWidget serialization and deserialization', () {\n     final widget = ButtonWidget(\n       id: 'test-id',\n       position: Rect.fromLTWH(10, 20, 120, 40),\n       text: 'Test Button',\n       backgroundColor: Colors.blue,\n       textColor: Colors.white,\n       action: 'navigate',\n       actionTarget: '/details',\n     );\n     \n     final json = widget.toJson();\n     final deserializedWidget = ButtonWidget.fromJson(json);\n     \n     expect(deserializedWidget.id, equals(widget.id));\n     expect(deserializedWidget.position, equals(widget.position));\n     expect(deserializedWidget.text, equals(widget.text));\n     expect(deserializedWidget.backgroundColor, equals(widget.backgroundColor));\n     expect(deserializedWidget.textColor, equals(widget.textColor));\n     expect(deserializedWidget.action, equals(widget.action));\n     expect(deserializedWidget.actionTarget, equals(widget.actionTarget));\n   });\n   ```\n\n2. **Widget Tests for Widget Selector Screen**:\n   - Test that the widget selector creates proper widget types:\n   ```dart\n   testWidgets('Widget selector creates proper VideoWidget', (WidgetTester tester) async {\n     // Setup test environment\n     await tester.pumpWidget(MaterialApp(home: WidgetSelectorScreen()));\n     \n     // Find and tap the video widget option\n     await tester.tap(find.text('Video'));\n     await tester.pump();\n     \n     // Verify a VideoWidget was created (not a TextWidget placeholder)\n     final createdWidget = getCreatedWidget(); // Helper method to get the created widget\n     expect(createdWidget, isA<VideoWidget>());\n     expect(createdWidget.type, equals(EditorWidgetType.video));\n   });\n   \n   testWidgets('Widget selector creates proper ButtonWidget', (WidgetTester tester) async {\n     // Setup test environment\n     await tester.pumpWidget(MaterialApp(home: WidgetSelectorScreen()));\n     \n     // Find and tap the button widget option\n     await tester.tap(find.text('Button'));\n     await tester.pump();\n     \n     // Verify a ButtonWidget was created (not a TextWidget with action properties)\n     final createdWidget = getCreatedWidget(); // Helper method to get the created widget\n     expect(createdWidget, isA<ButtonWidget>());\n     expect(createdWidget.type, equals(EditorWidgetType.button));\n   });\n   ```\n\n3. **Integration Tests for Widget System Conversion**:\n   - Test conversion between EditorWidget and CustomWidgetModel:\n   ```dart\n   test('EditorWidget to CustomWidgetModel conversion', () {\n     final videoWidget = VideoWidget(\n       id: 'test-id',\n       position: Rect.fromLTWH(10, 20, 200, 150),\n       videoUrl: 'https://example.com/video.mp4',\n       aspectRatio: 16/9,\n     );\n     \n     final customModel = videoWidget.toCustomWidgetModel();\n     \n     expect(customModel.id, equals(videoWidget.id));\n     expect(customModel.type, equals('video'));\n     expect(customModel.position, equals(videoWidget.position));\n     expect(customModel.properties['videoUrl'], equals(videoWidget.videoUrl));\n     expect(customModel.properties['aspectRatio'], equals(videoWidget.aspectRatio));\n   });\n   \n   test('CustomWidgetModel to EditorWidget conversion', () {\n     final customModel = CustomWidgetModel(\n       id: 'test-id',\n       type: 'video',\n       properties: {\n         'videoUrl': 'https://example.com/video.mp4',\n         'autoPlay': true,\n         'aspectRatio': 4/3,\n       },\n       position: Rect.fromLTWH(10, 20, 200, 150),\n     );\n     \n     final editorWidget = customModel.toEditorWidget();\n     \n     expect(editorWidget, isA<VideoWidget>());\n     expect(editorWidget.id, equals(customModel.id));\n     expect(editorWidget.position, equals(customModel.position));\n     expect((editorWidget as VideoWidget).videoUrl, equals(customModel.properties['videoUrl']));\n     expect((editorWidget as VideoWidget).autoPlay, equals(customModel.properties['autoPlay']));\n     expect((editorWidget as VideoWidget).aspectRatio, equals(customModel.properties['aspectRatio']));\n   });\n   ```\n\n4. **End-to-End Tests for Widget Creation and Editing**:\n   - Test the complete workflow of creating and editing different widget types:\n   ```dart\n   testWidgets('Create and edit video widget', (WidgetTester tester) async {\n     // Setup test environment with editor screen\n     await tester.pumpWidget(MaterialApp(home: CustomDraggableEditor()));\n     \n     // Add a video widget\n     await addVideoWidget(tester); // Helper method to add a video widget\n     await tester.pump();\n     \n     // Verify video widget is created and displayed\n     expect(find.byType(VideoWidget), findsOneWidget);\n     \n     // Open editor for the video widget\n     await tester.tap(find.byType(VideoWidget));\n     await tester.pumpAndSettle();\n     \n     // Edit video properties\n     await tester.enterText(find.byKey(Key('videoUrl')), 'https://example.com/new-video.mp4');\n     await tester.tap(find.text('Save'));\n     await tester.pumpAndSettle();\n     \n     // Verify changes were applied\n     final videoWidget = getVideoWidget(); // Helper method to get the video widget\n     expect(videoWidget.videoUrl, equals('https://example.com/new-video.mp4'));\n   });\n   ```\n\n5. **Visual Regression Tests**:\n   - Create screenshot tests to verify the visual appearance of different widget types:\n   ```dart\n   testWidgets('Video widget renders correctly', (WidgetTester tester) async {\n     // Setup test environment with a video widget\n     await tester.pumpWidget(MaterialApp(\n       home: Scaffold(\n         body: VideoWidgetRenderer(\n           widget: VideoWidget(\n             id: 'test-id',\n             position: Rect.fromLTWH(10, 20, 200, 150),\n             videoUrl: 'https://example.com/video.mp4',\n           ),\n         ),\n       ),\n     ));\n     \n     // Take screenshot and compare with golden file\n     await expectLater(\n       find.byType(VideoWidgetRenderer),\n       matchesGoldenFile('video_widget_render.png'),\n     );\n   });\n   ```\n\n6. **System Tests for Widget Template Service Integration**:\n   - Test that templates from WidgetTemplateService are correctly converted to EditorWidget instances:\n   ```dart\n   testWidgets('Widget templates are correctly converted to EditorWidgets', (WidgetTester tester) async {\n     // Mock WidgetTemplateService\n     final mockService = MockWidgetTemplateService();\n     when(mockService.getTemplates()).thenAnswer((_) async => [\n       CustomWidgetModel(\n         id: 'template-1',\n         type: 'video',\n         properties: {'videoUrl': 'https://example.com/template.mp4'},\n         position: Rect.fromLTWH(0, 0, 200, 150),\n       ),\n     ]);\n     \n     // Setup test environment with mocked service\n     await tester.pumpWidget(MaterialApp(\n       home: WidgetSelectorScreen(templateService: mockService),\n     ));\n     \n     // Wait for templates to load\n     await tester.pump();\n     \n     // Verify templates are converted to EditorWidgets\n     final templateWidgets = getTemplateWidgets(); // Helper method to get template widgets\n     expect(templateWidgets.length, equals(1));\n     expect(templateWidgets.first, isA<VideoWidget>());\n     expect((templateWidgets.first as VideoWidget).videoUrl, equals('https://example.com/template.mp4'));\n   });\n   ```\n\n7. **Drag Operation Tests**:\n   - Test that drag operations work correctly with new widget types:\n   ```dart\n   testWidgets('Video widget can be dragged correctly', (WidgetTester tester) async {\n     // Setup test environment with editor screen\n     await tester.pumpWidget(MaterialApp(home: CustomDraggableEditor()));\n     \n     // Add a video widget\n     await addVideoWidget(tester);\n     await tester.pump();\n     \n     // Get initial position\n     final initialWidget = getVideoWidget();\n     final initialPosition = initialWidget.position;\n     \n     // Perform drag operation\n     await tester.drag(find.byType(VideoWidget), Offset(50, 50));\n     await tester.pumpAndSettle();\n     \n     // Get new position\n     final updatedWidget = getVideoWidget();\n     final updatedPosition = updatedWidget.position;\n     \n     // Verify position changed correctly\n     expect(updatedPosition.left, equals(initialPosition.left + 50));\n     expect(updatedPosition.top, equals(initialPosition.top + 50));\n   });\n   ```",
        "subtasks": [
          {
            "id": 1,
            "title": "Update EditorWidgetType Enum",
            "description": "Add Video and Button to the EditorWidgetType enum",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create VideoWidget Class",
            "description": "Implement VideoWidget class extending EditorWidget with videoUrl, autoPlay, showControls, and aspectRatio properties",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create ButtonWidget Class",
            "description": "Implement ButtonWidget class extending EditorWidget with text, colors, action, and actionTarget properties",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Update Factory Methods",
            "description": "Update EditorWidget.fromType factory method to handle Video and Button types",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Update Serialization/Deserialization",
            "description": "Implement proper serialization/deserialization for VideoWidget and ButtonWidget",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Fix widget_selector_screen.dart",
            "description": "Update widget creation logic to use proper VideoWidget and ButtonWidget classes instead of TextWidget workarounds",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Widget Rendering",
            "description": "Verify EditorWidget system can properly render VideoWidget and ButtonWidget",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Test Widget Creation and Editing Flow",
            "description": "Test the complete workflow of creating and editing different widget types end-to-end",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Implement CustomWidgetModel Compatibility",
            "description": "Create conversion methods between EditorWidget and CustomWidgetModel systems",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Test Drag Operations",
            "description": "Verify that drag operations work correctly with new widget types",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 15,
        "title": "Develop Multi-Provider Map Widgets with Location Search and Save",
        "description": "Create three map widgets (Google, Kakao, Naver) with unified and individual app modes, supporting location search and the ability to save locations.",
        "details": "Implement three distinct map widgets for Google Maps, Kakao Maps, and Naver Maps, each supporting location search and location saving. Architect the solution to allow both a combined app (where users can switch between providers) and standalone apps for each provider. For each map provider, integrate their respective Flutter SDKs or web views as appropriate. Implement a unified interface for location search, utilizing each provider's geocoding API (e.g., Google Maps Geocoding, Kakao Local API, Naver Map Geocoding). Design a location search bar that queries the selected provider and displays results as selectable markers. Add functionality to save selected locations to the app's data store (using VenueModel from the core data models). Ensure saved locations can be retrieved and displayed on the map. Consider user permissions for location access and error handling for API failures. Provide clear UI cues for provider switching and saved location management. Follow best practices for state management and modular widget design.",
        "testStrategy": "1. Verify each map widget initializes and displays the correct provider's map. 2. Test location search for each provider, ensuring accurate geocoding and marker placement. 3. Save multiple locations and confirm they persist and display correctly on all map widgets. 4. Switch between providers in the combined app and ensure state consistency. 5. Test standalone map apps for each provider for full functionality. 6. Simulate API failures and verify graceful error handling. 7. Test on multiple devices and screen sizes. 8. Write unit and widget tests for search, save, and provider switching logic.",
        "status": "done",
        "dependencies": [
          1,
          5
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate Map Provider SDKs",
            "description": "Integrate the Flutter SDKs or web views for Google Maps, Kakao Maps, and Naver Maps into the project, ensuring each can be displayed as a widget.",
            "dependencies": [],
            "details": "Set up the necessary dependencies and permissions for each map provider. Ensure that each map widget can be rendered independently within the app.",
            "status": "done",
            "testStrategy": "Verify that each map provider widget loads correctly and displays a basic map view in both standalone and unified modes."
          },
          {
            "id": 2,
            "title": "Implement Unified and Individual App Modes",
            "description": "Architect the solution to support both a combined app (with provider switching) and standalone apps for each map provider.",
            "dependencies": [
              1
            ],
            "details": "Design the app structure to allow users to switch between map providers in a unified interface, as well as run each provider as a separate app. Provide clear UI cues for switching and mode selection.",
            "status": "done",
            "testStrategy": "Test switching between providers in the unified app and launching each provider in standalone mode, ensuring correct map rendering and UI feedback."
          },
          {
            "id": 3,
            "title": "Develop Unified Location Search Interface",
            "description": "Create a location search bar that queries the selected provider's geocoding API and displays results as selectable markers on the map.",
            "dependencies": [
              2
            ],
            "details": "Integrate Google Maps Geocoding, Kakao Local API, and Naver Map Geocoding for location search. Ensure the search bar dynamically uses the active provider's API and displays results appropriately.",
            "status": "done",
            "testStrategy": "Perform searches with each provider, verify that results are accurate, markers appear on the map, and selecting a result updates the map view."
          },
          {
            "id": 4,
            "title": "Implement Location Save and Retrieval Functionality",
            "description": "Enable users to save selected locations to the app's data store using VenueModel, and retrieve/display saved locations on the map.",
            "dependencies": [
              3
            ],
            "details": "Connect the location selection to the data model, allowing users to save locations. Implement retrieval and display of saved locations as markers, with management options.",
            "status": "done",
            "testStrategy": "Save multiple locations with each provider, verify persistence, and ensure saved locations are correctly displayed and managed on the map."
          },
          {
            "id": 5,
            "title": "Handle Permissions, Error States, and State Management",
            "description": "Implement user permission handling for location access, robust error handling for API failures, and best practices for state management and modular widget design.",
            "dependencies": [
              4
            ],
            "details": "Ensure the app requests and manages location permissions appropriately. Handle errors from map and geocoding APIs gracefully. Use state management patterns (e.g., Provider, Bloc) to maintain modularity and reliability.",
            "status": "done",
            "testStrategy": "Test permission flows, simulate API errors, and review state transitions for correctness and user experience."
          }
        ]
      },
      {
        "id": 16,
        "title": "Research and Implement Alternative Marker Solution for Google Maps on Flutter Web",
        "description": "Investigate and implement a reliable alternative to native Google Maps markers for the Flutter web platform to resolve the LegacyJavaScriptObject error and ensure proper venue location display.",
        "details": "This task involves researching and implementing a solution for the Google Maps marker issue on Flutter web platform. The current implementation using native Marker objects is causing LegacyJavaScriptObject errors.\n\n1. **Investigation Phase**:\n   - Document the exact error conditions and when they occur\n   - Research known issues with Google Maps Flutter plugin on web platform\n   - Explore the following alternative approaches:\n     - Custom overlay widgets using Stack and Positioned widgets\n     - HTML markers using HtmlElementView\n     - Custom marker implementation using OverlayEntry\n     - Alternative mapping libraries (MapBox, OpenStreetMap, etc.)\n\n2. **Solution Design**:\n   - Create a platform-specific implementation that uses different marker approaches for web vs mobile\n   - Design a common interface that works across platforms\n   - Ensure the solution supports:\n     - Custom marker icons/widgets\n     - Marker tap events\n     - Info windows or popups\n     - Proper positioning\n\n3. **Implementation**:\n   - Create a MarkerService class that handles platform differences:\n   ```dart\n   class MarkerService {\n     Widget buildMarker(BuildContext context, LatLng position, {\n       Widget? icon,\n       VoidCallback? onTap,\n       String? title,\n     }) {\n       if (kIsWeb) {\n         // Web-specific implementation\n         return CustomWebMarker(\n           position: position,\n           icon: icon,\n           onTap: onTap,\n           title: title,\n         );\n       } else {\n         // Mobile implementation using native markers\n         return NativeMarker(\n           position: position,\n           icon: icon,\n           onTap: onTap,\n           title: title,\n         );\n       }\n     }\n   }\n   ```\n\n4. **Web-specific Implementation Options**:\n   - **Custom Overlay Approach**:\n   ```dart\n   class CustomWebMarker extends StatelessWidget {\n     final LatLng position;\n     final Widget? icon;\n     final VoidCallback? onTap;\n     final String? title;\n     \n     @override\n     Widget build(BuildContext context) {\n       return Positioned(\n         left: calculatePixelX(position),\n         top: calculatePixelY(position),\n         child: GestureDetector(\n           onTap: onTap,\n           child: icon ?? Icon(Icons.location_on, color: Colors.red),\n         ),\n       );\n     }\n   }\n   ```\n   \n   - **HTML Marker Approach**:\n   ```dart\n   // Using HtmlElementView to create DOM elements for markers\n   ui.platformViewRegistry.registerViewFactory(\n     'web-marker-$markerId',\n     (int viewId) {\n       final marker = html.DivElement()\n         ..id = 'marker-$markerId'\n         ..style.position = 'absolute'\n         ..style.cursor = 'pointer';\n       // Add marker content and styling\n       return marker;\n     },\n   );\n   ```\n\n5. **Integration with Venue Display**:\n   - Update the venue display screen to use the new marker solution\n   - Ensure proper positioning of venue markers on the map\n   - Add venue details in marker popups/info windows\n   - Test across different browsers and devices\n\n6. **Performance Considerations**:\n   - Implement marker clustering for multiple locations if needed\n   - Optimize marker rendering for better performance\n   - Consider lazy loading of marker assets",
        "testStrategy": "1. **Unit Testing**:\n   - Create unit tests for the MarkerService class\n   - Test platform detection logic to ensure correct implementation is used\n   - Mock Google Maps controller to verify marker positioning calculations\n\n2. **Widget Testing**:\n   - Create widget tests for custom marker components\n   - Test marker tap events and info window display\n   - Verify marker positioning and appearance\n\n3. **Integration Testing**:\n   - Test the complete map view with markers on both web and mobile platforms\n   - Verify markers appear at the correct locations\n   - Test interaction with markers (tapping, info windows)\n\n4. **Cross-browser Testing**:\n   - Test the solution on multiple browsers (Chrome, Firefox, Safari, Edge)\n   - Verify consistent behavior across different browser versions\n   - Test on different screen sizes and resolutions\n\n5. **Performance Testing**:\n   - Measure and compare rendering performance with different marker implementations\n   - Test with multiple markers to ensure scalability\n   - Monitor memory usage during extended map interaction\n\n6. **Error Handling Testing**:\n   - Verify graceful degradation if marker assets fail to load\n   - Test behavior when map initialization is delayed\n   - Ensure error messages are user-friendly\n\n7. **Manual Testing Checklist**:\n   - Verify marker appearance matches design specifications\n   - Confirm marker positioning is accurate for venue locations\n   - Test marker interactions on touch devices\n   - Verify info windows display correct venue information",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Complete Individual Map Widgets Implementation and API Key Integration",
        "description": "Finalize the implementation of individual map widgets by configuring API key management for Naver and Kakao Maps, thoroughly testing all map widget types, ensuring robust error handling, and verifying backward compatibility with the multi-map widget.",
        "details": "1. Implement a secure and modular API key configuration system for Naver Maps and Kakao Maps, allowing keys to be injected at runtime or via environment variables. Use placeholder values and clear error messaging when keys are missing, and document the process for updating keys once provided by the user. Follow best practices for API key management, including restricting keys by platform and API usage where possible[2].\n2. Test all individual map widget types (Google, Naver, Kakao) for correct initialization, map display, and interaction. Ensure the widget selector UI lists all map options and allows seamless switching between providers.\n3. Implement and test editing functionality for each map widget type within the editor system, verifying that changes persist and render correctly.\n4. Ensure backward compatibility with the existing multi-map widget by running regression tests and confirming that legacy data and configurations continue to work as expected.\n5. Add robust error handling for cases where API keys are missing or invalid, displaying user-friendly error messages and preventing crashes. Simulate error scenarios using network request mocking libraries to verify graceful degradation and error reporting[1].\n6. Update documentation to reflect new configuration and usage patterns for all map widgets.",
        "testStrategy": "- Use integration and widget tests to verify that each map widget (Google, Naver, Kakao) initializes, displays, and interacts correctly with valid and missing API keys.\n- Mock API responses and simulate error conditions (e.g., missing/invalid keys, network failures) to ensure error handling logic works as intended[1].\n- Test the widget selector UI to confirm all map options are visible and selectable.\n- Edit each map widget type in the editor and verify changes persist and render correctly.\n- Run regression tests to ensure backward compatibility with the multi-map widget and legacy data.\n- Review logs and UI for appropriate error messages and absence of crashes during initialization failures.",
        "status": "pending",
        "dependencies": [
          15,
          11
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-01T13:41:34.057Z",
      "updated": "2025-07-08T18:16:10.067Z",
      "description": "Tasks for master context"
    }
  }
}